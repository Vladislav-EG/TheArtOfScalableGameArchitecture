# Лучшие практики для создания улучшаемой, масштабируемой, оптимизированной, архитектуры игры

# About

Добрый день читатель. 
Архитектура создаваемой вами игры - творческое самовыражение программиста, проявление его фантазии, видения, вдохновения, 
как и любое другое творчество, принятие таких решений основано на опыте, базе, характере и чувственных восприятиях разработчика. 
Ниже описано мое видение, я не претендую на правду в последней инстанции, думаю никто и никогда ее не найдет, я хочу поделиться
своими наработками и услышать фидбек!
  
Ниже в текстовом формате, я хочу поделиться своими мыслями как это должно выглядит и функционировать на мой взгляд. 
Сам проект реализовывает эти практики с очень плохим неотполированным кодом, это все наброски, но они работают.
Проект это холст для обучения и экспериментов.
  
Если у вас есть советы, предложения, возражения, дополнения пожалуйста напишите мне подскажите и исправьте, мне будет очень интересно послушать и лучше разобраться в этом вопросе.

P.S. DI - не используется, это только замедлит вас, в Unity и так есть DI. Каждый хочет зарабатывать деньги своим любимым делом и мы программисты тоже.
Если работодатель требует DI, не нам решать, не нам спорить с лидом проекта. 
Проект создан понимания как должна работать

# Bootstrap Scene

> [!TIP]
> Bootstrap Scene - фундамент, корни будущей архитектуры, при поливе превращающиеся в цифровой сад готовых дизайнерских решений.

Наличие Bootstrap-сцены, реализованной с помощью паттерна Entry Point, является ключевым элементом архитектуры проекта.
Bootstrap-сцена загружается первой при старте приложения и остаётся активной на протяжении всей работы игры, 
функционируя как аддитивная базовая сцена, поверх которой загружаются остальные игровые уровни.

Её основная задача — инициализация, конфигурация и управление жизненным циклом всех базовых сервисов, необходимых для работы проекта. 
Например, в рамках Bootstrap-сцены создаются и запускаются следующие подсистемы:
- Core-сервисы: SceneLoaderService, SaveLoadService, Logger, EventManager, GameStateMachine.
- Gameplay-сервисы: InputService, AudioService, UIService и другие, отвечающие за геймплейную логику.
- Optional-сервисы: аналитика, реклама, метрики, внутренняя отладка и т.п.

> [!TIP]
> Выше представлены примеры подсистем и сервисов.

Такой подход решает одну из ключевых проблем крупной архитектуры Unity — отсутствие гарантированного порядка инициализации объектов, 
особенно при переходах между сценами. Bootstrap-сцена обеспечивает строго контролируемый жизненный цикл сервисов 
и детерминированный порядок их запуска, что делает взаимодействие между компонентами прозрачным и предсказуемым.

Кроме того, использование Bootstrap-сцены позволяет полностью разделить ответственность между слоями системы — геймплейными, 
инфраструктурными и вспомогательными. Это упрощает тестирование, повторное использование кода и поддержку проекта на 
протяжении всего его жизненного цикла.

# Services

Сервисы являются основой инфраструктуры проекта — они выполняют ключевые задачи, 
обеспечивая работу всей игры на уровне ядра (Core) и геймплея (Gameplay).
Практически в любом проекте Unity они присутствуют, независимо от жанра или масштаба. 
Однако важно не только то, какие сервисы используются, но и как они структурированы, инициализируются и взаимодействуют между собой,
и остальным кодом. Про инициализацию было сказано выше, это происходит в Boostrap-сцене, так же может быть сервис, который будет 
инициализироваться перед уровнем где он используется и выгружаться после его завершения.

Существует несколько распространённых подходов к внедрению и управлению сервисами:

- Singleton - самый простой способ организации сервисов. Каждый сервис реализуется как синглтон, инициализуерется в Boostrap-сцене, 
может существовать как Monobehavior-объект, либо как C# класс.
- ServiceLocator - более гибкий способ, имеющий некоторую простоту Singleton и структурность, организованность DI.
Все сервисы регистрируются в ServiceLocator, расположенном в Bootstrap-сцене (в виде MonoBehaviour или отдельного статического объекта).
Service Locator можно инкапсулировать, чтобы ограничить область доступа и повысить читаемость, например будут отдельные локаторы для gameplay, core, debug
- DI Container - DI развитие идеи ServiceLocator, основанной на принципе инверсии контроля (Inversion of Control).
Если при использовании Service Locator объект сам запрашивает нужные зависимости, то в случае DI — зависимости "внедряются" извне (в конструктор, поля или методы). 
Это делает систему более гибкой, тестируемой и легко расширяемой. 
Можно реализовать свой DI, но так же есть удобные готовые решения для Unity:
  - Zenject
  - Reflex
  - VContainer

| Подход          | Преимущество  | Недостатки  |
|-----------------|---------------|-------------|
| Singleton       | Просто и быстро  | Трудно тестировать, плохая изоляция |
| Service Locator | Централизовано, меньше хаоса  | Глобальные зависимости |
| DI              | Тестируемо, гибко, масштабируемо  | Сложнее на старте |

По моему мнению очень важно какое решение примет программист для создания сервисов, как он им позволит общаться с остальным кодом.



Пример сервисов:
