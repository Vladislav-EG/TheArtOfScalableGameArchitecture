# Лучшие практики для создания улучшаемой, масштабируемой, оптимизированной, архитектуры игры

# About

Добрый день читатель. 
Архитектура создаваемой вами игры - творческое самовыражение программиста, проявление его фантазии, видения, вдохновения, 
как и любое другое творчество, принятие таких решений основано на опыте, базе, характере и чувственных восприятиях разработчика. 
Ниже описано мое видение, я не претендую на правду в последней инстанции, думаю никто и никогда ее не найдет, я хочу поделиться
своими наработками и услышать фидбек!
  
Ниже в текстовом формате, я хочу поделиться своими мыслями как это должно выглядит и функционировать на мой взгляд. 
Сам проект реализовывает эти практики с очень плохим неотполированным кодом, это все наброски, но они работают.
Проект это холст для обучения и экспериментов.
  
Если у вас есть советы, предложения, возражения, дополнения пожалуйста напишите мне подскажите и исправьте, мне будет очень интересно послушать и лучше разобраться в этом вопросе.

P.S. DI - не используется, это только замедлит вас, в Unity и так есть DI. Каждый хочет зарабатывать деньги своим любимым делом и мы программисты тоже.
Если работодатель требует DI, не нам решать, не нам спорить с лидом проекта. 
Проект создан понимания как должна работать

# Bootstrap Scene

> [!TIP]
> Bootstrap Scene - фундамент, корни будущей архитектуры, при поливе превращающиеся в цифровой сад готовых дизайнерских решений.

Наличие Bootstrap-сцены, реализованной с помощью паттерна Entry Point, является ключевым элементом архитектуры проекта.
Bootstrap-сцена загружается первой при старте приложения и остаётся активной на протяжении всей работы игры, 
функционируя как аддитивная базовая сцена, поверх которой загружаются остальные игровые уровни.

Её основная задача — инициализация, конфигурация и управление жизненным циклом всех базовых сервисов, необходимых для работы проекта. 
Например, в рамках Bootstrap-сцены создаются и запускаются следующие подсистемы:
- Core-сервисы: SceneLoaderService, SaveLoadService, Logger, EventManager, GameStateMachine.
- Gameplay-сервисы: InputService, AudioService, UIService и другие, отвечающие за геймплейную логику.
- Optional-сервисы: аналитика, реклама, метрики, внутренняя отладка и т.п.

> [!TIP]
> Выше представлены примеры подсистем и сервисов.

Такой подход решает одну из ключевых проблем крупной архитектуры Unity — отсутствие гарантированного порядка инициализации объектов, 
особенно при переходах между сценами. Bootstrap-сцена обеспечивает строго контролируемый жизненный цикл сервисов 
и детерминированный порядок их запуска, что делает взаимодействие между компонентами прозрачным и предсказуемым.

Кроме того, использование Bootstrap-сцены позволяет полностью разделить ответственность между слоями системы — геймплейными, 
инфраструктурными и вспомогательными. Это упрощает тестирование, повторное использование кода и поддержку проекта на 
протяжении всего его жизненного цикла.

# Services

Сервисы являются основой инфраструктуры проекта — они выполняют ключевые задачи, 
обеспечивая работу всей игры на уровне ядра (Core) и геймплея (Gameplay).
Практически в любом проекте Unity они присутствуют, независимо от жанра или масштаба. 
Однако важно не только то, какие сервисы используются, но и как они структурированы, инициализируются и взаимодействуют между собой,
и остальным кодом. Про инициализацию было сказано выше, это происходит в Boostrap-сцене, так же может быть сервис, который будет 
инициализироваться перед уровнем где он используется и выгружаться после его завершения.

Существует несколько распространённых подходов к внедрению и управлению сервисами:

- Singleton - самый простой способ организации сервисов. Каждый сервис реализуется как синглтон, инициализуерется в Boostrap-сцене, 
может существовать как Monobehavior-объект, либо как C# класс.
- ServiceLocator - более гибкий способ, имеющий некоторую простоту Singleton и структурность, организованность DI.
Все сервисы регистрируются в ServiceLocator, расположенном в Bootstrap-сцене (в виде MonoBehaviour или отдельного статического объекта).
Service Locator можно инкапсулировать, чтобы ограничить область доступа и повысить читаемость, например будут отдельные локаторы для gameplay, core, debug
- DI Container - DI развитие идеи ServiceLocator, основанной на принципе инверсии контроля (Inversion of Control).
Если при использовании Service Locator объект сам запрашивает нужные зависимости, то в случае DI — зависимости "внедряются" извне (в конструктор, поля или методы). 
Это делает систему более гибкой, тестируемой и легко расширяемой. 
Можно реализовать свой DI, но так же есть удобные готовые решения для Unity:
  - Zenject
  - Reflex
  - VContainer

| Подход          | Преимущество  | Недостатки  |
|-----------------|---------------|-------------|
| Singleton       | Просто и быстро  | Трудно тестировать, плохая изоляция |
| Service Locator | Централизовано, меньше хаоса  | Глобальные зависимости |
| DI              | Тестируемо, гибко, масштабируемо  | Сложнее на старте |



По моему мнению очень важно какое решение примет программист для создания сервисов, как он им позволит общаться с остальным кодом.

Пример сервисов:

# StateMachine

State Machine (машина состояний) — невероятно полезный паттерн, который помогает выстроить чистую, 
прозрачную и управляемую архитектуру поведения объектов.

Он инкапсулирует логику каждого состояния в отдельном классе, чётко разделяет ответственность, 
изолирует переходы и выстраивает предсказуемый порядок выполнения кода.

## Виды StateMachine

Существует два основных типа:
- Обычная State Machine — простая последовательность состояний и переходов;  
- Иерархическая (Hierarchical State Machine) — поддерживает вложенные состояния и позволяет выстраивать более сложные структуры поведения; 

> [!TIP]
> Перед созданием StateMachine, стоит заранее проанализировать понадобиться ли иерархия,
чтобы не столкнуться в будущем с разросшимся количеством переходов.

## Подходы к организации переходов

Еще есть два варианта реализации переходов между состояниями:

1. **Локальные переходы внутри состояний**

Каждое состояние само определяет, при каких условиях оно завершает работу и в какое состояние нужно перейти.
То есть логика переходов инкапсулирована прямо в классе состояния.

``` C#
public class AttackState : IState
{
    private readonly Player _player;
    private readonly StateMachine _machine;

    public void Update()
    {
        if (_player.Health <= 0)
            _machine.Enter<DeathState>();

        if (_player.HasNoTarget)
            _machine.Enter<IdleState>();
    }
}
```

Данный подход может подойти для простых систем, в которых не так много состояний.

2. **Централизованные переходы (предикаты, правила, Transition Map)**

Все переходы описываются в одном месте — обычно в отдельном конфигурационном классе.
Состояния становятся “чистыми”: они только выполняют свою внутреннюю логику, а решение, когда и куда перейти, 
принимает внешний контроллер на основе набора условий (предикатов).

``` C#
machine.AddTransition(AttackState, IdleState, () => player.HasNoTarget);
machine.AddTransition(AnyState, DeathState, () => player.Health <= 0);
```

Такой подход прекрасно подойдет для больших, иерархических, масштабных систем, так как будет 
проще контролировать возрастающие количество переходов.

## Библиотеки

Для Unity присутствует множество библиотек с уже реализововаными машинами состояний,
но из всех, мне приглянулась [UnityHFSM](https://github.com/Inspiaaa/UnityHFSM). 
В ней понятный, структурированный, документированный код, поддержка иерархии и централизованных переходов,
множество различных переходов.










Я считаю, что стоит сразу реализовывать или пользоваться стейтмашиной с возможностью использования иерархии. 
Иерархия позволяет избежать дублирования, улучшает читаемость, 
можете попробовать создать два контроллера персонажа, который будет обладать большим количеством действий, 
без иерархии устанете прописывать переходы между всеми состояниями. Всегда можно заходить свою, 
но есть отличная уже сделанная со многими фишками  - Unity HFSM. Стейт машина отлично 
подходит для реализации главного героя, основного цикла игры, интерактивных объектов, AI, UI и так далее. 

https://github.com/Inspiaaa/UnityHFSM

Inspiaaa/UnityHFSM: A fast, tried-and-tested hierarchical finite state machine library for Unity, designed to be easy to use yet powerful without compromising performance.
